generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("LOCAL_DB_URL")
}

model User {
  id          Int            @id @default(autoincrement())
  username    String         @unique
  otp         Int?
  otpExpireAt DateTime?
  avatar      Bytes?
  phoneNumber String         @unique
  randomInt   Int            @default(0)
  gender      Gender?
  orders      Order[]
  seller      Seller?
  followers   Relationship[] @relation("follower")
  followings  Relationship[] @relation("following")
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  Review      Review[]
  VideoLike   VideoLike[]
  address     Address?
}

model Address {
  id       Int     @id @default(autoincrement())
  userId   Int?    @unique
  sellerId Int?    @unique
  address1 String
  address2 String?
  city     String
  state    String?
  country  String
  pincode  String
  user     User?   @relation(fields: [userId], references: [id])
  seller   Seller? @relation(fields: [sellerId], references: [id])
}

model Seller {
  id             Int              @id
  active         Boolean          @default(false)
  brandName      String
  bio            String
  contactNumber  String
  email          String
  type           String
  categoryId     Int
  deliveryType   DeliveryType
  shopOpen       Boolean          @default(false)
  products       Product[]
  category       Category         @relation(fields: [categoryId], references: [id])
  user           User             @relation(fields: [id], references: [id])
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  address        Address?
  DeliveryOption DeliveryOption[]
  Order          Order[]
}

model DeliveryOption {
  id             Int    @id @default(autoincrement())
  sellerId       Int
  seller         Seller @relation(fields: [sellerId], references: [id], onDelete: Cascade)
  minimumPrice   Float
  deliveryFee    Int
  deliveryRadius Int

  @@index([sellerId, deliveryRadius])
}

model Relationship {
  id          Int      @id @default(autoincrement())
  followerId  Int
  followingId Int
  follower    User     @relation("follower", fields: [followerId], references: [id])
  following   User     @relation("following", fields: [followingId], references: [id])
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([followerId, followingId])
}

model Category {
  id           Int      @id @default(autoincrement())
  categoryName String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  Seller       Seller[]
}

model Product {
  id            Int         @id @default(autoincrement())
  name          String
  description   String?
  price         Float
  stockQuantity Int
  imageLink     String?
  sellerId      Int
  seller        Seller      @relation(fields: [sellerId], references: [id], onDelete: Cascade)
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  Video         Video[]
  Cart          Cart[]
  OrderItem     OrderItem[]
}

model Cart {
  productId Int
  userId    Int
  quantity  Int      @default(1)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  product   Product  @relation(fields: [productId], references: [id])

  @@id([productId, userId])
}

model Review {
  id          Int       @id @default(autoincrement())
  orderId     Int
  productId   Int
  userId      Int
  rating      Float
  description String?
  orderItem   OrderItem @relation(fields: [orderId, productId], references: [orderId, productId])
  user        User      @relation(fields: [userId], references: [id])
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@unique([orderId, productId])
}

model Order {
  id          Int         @id @default(autoincrement())
  userId      Int
  totalPrice  Float
  orderStatus OrderStatus @default(orderPlaced)
  user        User        @relation(fields: [userId], references: [id])
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  sellerId    Int
  Seller      Seller      @relation(fields: [sellerId], references: [id])
  OrderItem   OrderItem[]
}

model OrderItem {
  orderId   Int
  productId Int
  quantity  Int     @default(1)
  Product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  Order     Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  Review    Review?

  @@id([orderId, productId])
}

model Video {
  id              Int           @id @default(autoincrement())
  productId       Int
  videoMetaDataId Int           @unique
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  videoMetaData   VideoMetaData @relation(fields: [videoMetaDataId], references: [id], onDelete: Cascade)
  product         Product       @relation(fields: [productId], references: [id], onDelete: Cascade)
  VideoLike       VideoLike[]

  @@index([productId])
}

model VideoMetaData {
  id           Int      @id @default(autoincrement())
  url          String   @unique
  processedUrl String?
  thumbnailUrl String?
  video        Video?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

model VideoLike {
  userId    Int
  videoId   Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id])
  video     Video    @relation(fields: [videoId], references: [id], onDelete: Cascade)

  @@id([userId, videoId])
}

model WaitList {
  id          Int      @id @default(autoincrement())
  name        String
  location    String
  email       String   @unique
  phoneNumber String   @unique
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

enum Gender {
  MALE
  FEMALE
  OTHERS
}

enum TeamStatus {
  teamCreated
  teamConfirmed
  teamExpired
}

enum PurchaseType {
  individual
  team
}

enum OrderStatus {
  orderPlaced
  orderConfirmed
  productShipped
  productDelivered
  orderExpired
  orderCancelled
}

enum DeliveryType {
  noDelivery
  thirdPartyDelivery
  ownDelivery
}
